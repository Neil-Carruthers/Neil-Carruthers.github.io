{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<p>In recent versions of Solidity there have been a number of breaking changes that affect probably all contracts in one way or another. I decided that it might be helpful to other developers if I listed some of the more general ones that are going to come up no matter what you're building, especially if you're using an older tutorial or course that is based on a previous version of Solidity. I won't be trying to cover every single breaking change for every edge case. Those can always be found <a href=\"https://docs.soliditylang.org/en/v0.8.17/080-breaking-changes.html\">here</a></p>\n<h2>SPDX License Indentifiers</h2>\n<p>The first change that I want to mention is not actually a breaking change, but it will cause the compiler to throw a warning. Beginning with version 0.6.8 the compiler will encourage you to include an SPDX license identifier at the top of your source code file. This allows you to explicitly state whether or not the code is open source which is important for copyright reasons whenever you are making your source code publicly available.</p>\n<figure>\n<pre><span>// SPDX-License-Identifier: MIT</span></pre>\n<figcaption>Example of an SPDX license identifier on the first line of a source code file</figcaption>\n</figure>\n<p><a href=\"https://docs.soliditylang.org/en/v0.8.17/layout-of-source-files.html?highlight=spdx#spdx-license-identifier\">Source</a></p>\n<h2>Constructor Keyword</h2>\n<p>Beginning with version 0.5.0 you will no longer name your constructor function with a capitalized version of the contract name, as a new constructor keyword has been added to the language. The constructor function is the optional function that will be called upon contract creation. This is a breaking change so if you want to use newer versions of Solidity, make sure that you update your code accordingly.</p>\n<figure>\n<pre>\n<span>contract MyContract {\n...\nfunction MyContract(string someInitialValue) public {</span>\n</pre>\n<figcaption>Constructor function prior to version 0.5.0</figcaption>\n</figure>\n<p>Becomes...</p>\n<figure>\n<pre>\n<span>contract MyContract {\n...\nconstructor(string someInitialValue) public {</span>\n</pre>\n<figcaption>Constructor function beginning with version 0.5.0</figcaption>\n</figure>\n<p>Also worth noting is that with version 0.7.0 you are no longer required to mark a constructor function as public. The previous example can be further updated as such:</p>\n<figure>\n<pre>\n<span>contract MyContract {\n...\nconstructor(string someInitialValue) {</span>\n</pre>\n<figcaption>Constructor function beginning with version 0.7.0</figcaption>\n</figure>\n<p><a href=\"https://docs.soliditylang.org/en/v0.8.17/050-breaking-changes.html#constructors\">Source: Constructor keyword</a></p>\n<p><a href=\"https://docs.soliditylang.org/en/v0.8.17/070-breaking-changes.html#functions-and-events\">Source: Public no longer needed</a></p>\n<h2>Address Payable</h2>\n<p>Starting with version 0.5.0 the address data type has been split into address and address payable. Only the address payable type can use the transfer function. The address payable type can be directly converted into an address type but not vice versa.</p>\n<figure>\n<pre>\n<span>address recipient = recipientAddress;\npayable(recipient).transfer(value);</span>\n</pre>\n<figcaption>Example of how to directly convert an address into an address payable type</figcaption>\n</figure>\n<figure>\n<pre>\n<span>address payable[] public recipients;</span>\n</pre>\n<figcaption>Example of how to instantiate an array where each of its items are of the address payable type</figcaption>\n</figure>\n<p><a href=\"https://docs.soliditylang.org/en/v0.8.17/050-breaking-changes.html#explicitness-requirements\">Source</a></p>\n<h2>Explicit Data Locations</h2>\n<p>Since the release of version 0.5.0 the data location for all struct, array or mapping type variables must be explicitly declared. This includes function parameters and return types.</p>\n<figure>\n<pre>\n<span>function getAllRecipients() public view returns (address payable[]) {</span>\n</pre>\n<figcaption>Return type declaration prior to verion 0.5.0</figcaption>\n</figure>\n<p>Becomes ...</p>\n<figure>\n<pre>\n<span>function getAllRecipients() public view returns (address payable[] memory) {</span>\n</pre>\n<figcaption>Return type declaration beginning with verion 0.5.0</figcaption>\n</figure>\n<p><a href=\"https://docs.soliditylang.org/en/v0.8.17/050-breaking-changes.html#explicitness-requirements\">Source</a></p>\n<h2>Mappings Can Only Be Used In Storage</h2>\n<p>Beginning with version 0.7.0 if an array or struct contains a mapping it can only be used in storage. Previously this code would be valid:</p>\n<figure>\n<pre>\n<span>Request memory newRequest = Request({\n    key: value,\n    ...\n});\nrequests.push(newRequest);</span>\n</pre>\n<figcaption>Adding a mapping to a storage array prior to version 0.7.0</figcaption>\n</figure>\n<p>But in order to use version 0.7.0 or later it must be written like this:</p>\n<figure>\n<pre>\n<span>Request storage newRequest = requests.push();\nnewRequest.key = value;\n...</span>\n</pre>\n<figcaption>Adding a mapping to a storage array beginning with version 0.7.0</figcaption>\n</figure>\n<p>In the updated example we are pushing a new Request mapping into the array in storage and then changing the values associated with each of its keys. This is in contrast to creating a new Request mapping in memory and then pushing it to the array in storage.</p>\n<p><a href=\"https://docs.soliditylang.org/en/v0.8.17/070-breaking-changes.html#mappings-outside-storage\">Source</a></p>\n<h2>Shape of a Compiled Contract</h2>\n<p>When it comes to deploying a compiled smart contract onto the blockchain, there are two important pieces of data which need to be pulled off of the compiled contract. Over the years the shape of the compiled contract has changed, and the location within the JSON structure where the interface (ABI) and bytecode can be found has changed as well. Originally you would pull the interface and bytecode objects from the top level of the compiled contract JSON. This is still true for the interface, however the key has been renamed to abi. The bytecode can now be found under evm.bytecode.object.</p>\n<p>If you are trying to deploy a contract and you are getting errors about not being able to find the interface and bytecode, then you may need to update your code to look like this:</p>\n<figure>\n<pre>\n<span>await new web3.eth.Contract(compiledContract.abi)\n    .deploy({ data: compiledContract.evm.bytecode.object })\n    .send({ gas: '1000000', from: myAccount })</span>\n</pre>\n<figcaption>Example of finding the interface (abi) and bytecode of a compiled contract</figcaption>\n</figure>","frontmatter":{"title":"Solidity Major Changes","date":"2022-11-18","featured":true},"id":"5960d37b-a0a0-53a6-852f-8cb0ec25fb46","excerpt":"In recent versions of Solidity there have been a number of breaking changes that affect probably all contracts in one way or another. I decided that it might be helpful to other developers if I listed some of the more general ones that are going to…","fields":{"slug":"/solidity-migration/"}}},{"node":{"html":"<p>For an e-commerce application I'm working on I have a React client and an Express server and I needed some way of testing the Stripe checkout component during development.  In production, Heroku provides the Express server with a dynamic port number and when it serves the React application the client can correctly call the following code and have it routed to the appropriate port:</p>\n<figure>\n    <pre>\n<span>axios({\n    url: 'payment',\n    method: 'post',\n    data: {\n        amount: priceForStripe,\n        token\n    }\n})<span></pre>\n    <figcaption>components/stripe-button/stripe-button.component.jsx</figcaption>\n</figure>\n<p>However, during development, my Express server and my React application were being served from two separate ports on localhost and I needed a way to ensure that API calls made to my POST endpoint were able to find the correct port.  I needed a proxy:</p>\n<figure>\n    <pre><span>\"proxy\": \"http://localhost:5000\",<span></pre>\n    <figcaption>client/package.json</figcaption>\n</figure>\n<figure>\n    <pre><span>const port = process.env.PORT || 5000;<span></pre>\n    <figcaption>server.js</figcaption>\n</figure>\n<p>By providing the full address of the Express development server through a \"proxy\" key in the package.json file of the React application, the client knows to pass all unhandled requests to the Express server for processing.  In production, the Express server uses the PORT variable provided to it by the Heroku dyno, but in development it uses 5000, which is available to React through the proxy.</p>","frontmatter":{"title":"Send API Requests From React to Express During Development","date":"2021-08-15","featured":false},"id":"3772c068-2402-5063-94b4-e16dfbd060e0","excerpt":"For an e-commerce application I'm working on I have a React client and an Express server and I needed some way of testing the Stripe checkout component during development.  In production, Heroku provides the Express server with a dynamic port number…","fields":{"slug":"/react-proxy/"}}},{"node":{"html":"<p>As I've worked with other developers over the years, I've often noticed that it's a common tendency for people to try to figure things out as they go along. Instead of taking the time to think about everything upfront, they jump right in and just start coding. I'm not a fan of this strategy because I believe that it can easily lead to wasted resources when people unexpectedly build something the wrong way.</p>\n<p>Through my prior experiences as a mechanical designer I've learned a lot about how to design a product on paper before anyone attempts to build it. I believe that this experience is valuable in the software development industry, as many common mistakes can be avoided by planning everything out ahead of time using best practices and effective problem solving methods. It provides an opportunity to think about how everything should work, what resources are needed and the types of issues that may arise.</p>\n<p>Another valuable part of my experience as an engineering designer was learning how to design things based on best practices, job specifications and established industry standards. It creates a framework which puts the designer in the best possible position to succeed while avoiding reinventing the wheel.</p>","frontmatter":{"title":"TIL - How Engineering Has Informed My Software Design Philosophy","date":"2020-10-12","featured":false},"id":"53022591-2283-5a36-a235-9cd753f331cf","excerpt":"As I've worked with other developers over the years, I've often noticed that it's a common tendency for people to try to figure things out as they go along. Instead of taking the time to think about everything upfront, they jump right in and just…","fields":{"slug":"/til-engineering-tradition/"}}}]}},"pageContext":{}},"staticQueryHashes":["63159454"],"slicesMap":{}}